#!/usr/bin/env python
# (c) Copyright 2023 Premier Heart, LLC

import base64
import io
import json
import math
import os
import random
import requests
import sys
from datetime import datetime
import pandas as pd
import matplotlib.pyplot as plt

TOKEN_PATH_KEY = 'MCG_API_TOKEN_FILE'
TOKEN_KEY = 'MCG_API_TOKEN'

def get_api_token():
    if TOKEN_KEY in os.environ:
        return os.environ[TOKEN_KEY]
    elif TOKEN_PATH_KEY in os.environ:
        with open(os.environ[TOKEN_PATH_KEY], 'r') as f:
            return f.read().strip()
    else:
        raise "Missing token! Set either MCG_API_TOKEN or MCG_API_TOKEN_FILE in environment."

def send_api_request(server_url, token, data):
    header = { 'Authorization': token,
               'Content-Type': 'application/json' }
    response = requests.post(url=server_url, headers=header, json=data)
    return response

def build_request(inputs):
    return {
      "object-type": "analysis-request",
      "analysis": {
        "type": "mcg-differential",
        "options": { }
      },
      "output": {
        "result-diff-csv": {
            'delimiter': '|'
        },
        "result-json": {
            'in-place-json': True
        },
        "transform-heatmap": {
        },
        "transform-json": {
            'in-place-json': True
        }
      },
      "input": inputs,
      "comment": "(FAKE DATA) Generated by " + os.path.basename(__file__)
    }

def input_for_ecg_json(json_str, age=40, gender='M'):
    ts = datetime.now().strftime('%Y-%m-%d %H:%M:%S')
    return {
      "type": "ecg",
      "format": "json",
      "timestamp": ts,
      "age": age,
      "gender": gender,
      "data": json.loads(json_str)
    }

def decode_response(resp):
    if resp.status_code != 200:
        return {
                "object-type": "http-error",
                "timestamp": str(datetime.now),
                "message": "Unknown error: HTTP %d" % resp.status_code
        }
    return json.loads(resp.text)

def print_results_summary(res, indent="\t"):
    if 'comment' in res:
        print(indent + "Comment: " + res['comment'])

    print(indent + "Tracing Quality:")
    for fname, score in res['tracing-quality'].items():
        print(indent + indent + "%s : %d" % (fname, score))

    print(indent + "ECG Details:")
    for fname, lead_stats in res['ecg-stats'].items():
        print(indent + indent + fname)
        for lead, h in lead_stats.items():
            print(indent + indent + indent + "%s  Count: %d  High: %d  Low: %d  Baseline: %d  Total: %d  Peak Count: %d  Voltage: %0.2f  PPV: %d" % (lead, h['count'], h['high'], h['low'], h['baseline'], h['total'], h['peak_count'], h['voltage'], h['ppv']))

# ----------------------------------------------------------------------
# DIFFERENTIAL PLOT
default_dpi = 100
default_height = 768
default_width = 1024+1024

def plot_rows(ax, orig_df, diag_labels, legend=False):
    df = orig_df.iloc[:,3:]
    x_labels = []
    y_labels = []
    pos_x = [ ]
    pos_y = [ ]
    neg_x = [ ]
    neg_y = [ ]
    unstable_x = [ ]
    unstable_y = [ ]

    # diagnosis is Y axis
    for y, y_name in enumerate(df.columns):
        y_labels.append(y_name)
        # input is X axis
        for x_idx, row in df.iterrows():
            x_name = orig_df.inputs[x_idx]
            if isinstance(x_name, float):
                if math.isnan(x_name):
                    x_name = orig_df.groups[x_idx]
                else:
                    x_name = str(x_name) # actually an error
            if x_name not in x_labels:
                    x_labels.append(x_name)
            x = x_labels.index(x_name)

            # scatter plot point is either red X, Green +, or Blue -
            if row[y_name] == '+':
                pos_x.append(x)
                pos_y.append(y)
            elif row[y_name] == '-':
                neg_x.append(x)
                neg_y.append(y)
            else: # df.loc(idx, y) == 'X'
                unstable_x.append(x)
                unstable_y.append(y)

    ax.scatter(pos_x, pos_y, c='green', marker='P', label="always positive")
    ax.scatter(neg_x, neg_y, c='red', marker='_', s=100, label="always negative")
    ax.scatter(unstable_x, unstable_y, c='grey', marker='x', label="unstable")
    ax.grid(True, zorder=5, linestyle='dotted')
    if legend:
         ax.legend(loc='upper center', fontsize=6)

    ax.yaxis.set_ticks(list(range(len(y_labels))))
    if diag_labels:
        ax.set_yticklabels(y_labels, fontsize=8)  
    else:
        ax.set_yticklabels([])  

    ax.xaxis.set_ticks(list(range(len(x_labels))))
    ax.set_xticklabels(x_labels, rotation=315, ha='left', fontsize=6)  

def plot_differential(df,width=default_width, height=default_height, dpi=default_dpi):
    # NOTE: first five rows are comparison of both groups

    fig = plt.figure(figsize=[width/dpi, height/dpi], dpi=dpi)
    axes = fig.subplots(1, 4, width_ratios=[1, 3, 3, 3])

    # should be only two rows
    rows = df.loc[ df['operation'] == 'I']
    ax = axes[0]
    ax.title.set_text("Identity operation" )
    plot_rows(ax, rows, True, True)

    rows = df.loc[ df.operation.str.match(r"^A[0-9]*\^B[0-9]*")]
    ax = axes[1]
    ax.title.set_text("Intersection (items in both B and A)")
    plot_rows(ax, rows, False)

    rows = df.loc[ df.operation.str.match(r"^A[0-9]*\-B[0-9]*")]
    ax = axes[2]
    ax.title.set_text("Difference (items in A not in B)" )
    plot_rows(ax, rows, False)

    rows = df.loc[ df.operation.str.match(r"^B[0-9]*\-A[0-9]*")]
    ax = axes[3]
    ax.title.set_text("Difference (items in B not in A)" )
    plot_rows(ax, rows, True)
    ax.yaxis.set_label_position("right")
    ax.yaxis.tick_right()

    fig.suptitle('MCG Diagnosis : Differential Analysis')
    fig.tight_layout()
    plt.show()
    plt.close()

# ----------------------------------------------------------------------
# MAIN
if __name__ == '__main__':
    url = "https://api.premierheart.com/api/v1/analyze"
    if len(sys.argv) > 1:
        url = sys.argv[1]

    inputs = [ ]
    for x in range(5):
        fname = os.path.join(os.path.dirname(os.path.abspath(__file__)), 'data', ("ecg_pre_%d.json" % (x+1)))
        with open(fname, 'r') as f:
            h_input = input_for_ecg_json(f.read())
            h_input['name'] = os.path.splitext(os.path.basename(fname))[0]
            h_input['group'] = 'pre'
            inputs.append(h_input)
        print("Read input: %s" % (fname))
    for x in range(3):
        fname = os.path.join(os.path.dirname(os.path.abspath(__file__)), 'data', ("ecg_post_%d.json" % (x+1)))
        with open(fname, 'r') as f:
            h_input = input_for_ecg_json(f.read())
            h_input['name'] = os.path.splitext(os.path.basename(fname))[0]
            h_input['group'] = 'post'
            inputs.append(h_input)
        print("Read input: %s" % (fname))

    token = get_api_token()
    data = build_request( inputs )
    resp = send_api_request(url, token, data)
    results = decode_response(resp)

    if results['object-type'] != 'analysis-result':
        print("Unexpected return value from API server:")
        for k,v in results.items():
            print("\t%s: %s" % (k, v))
        sys.exit()

    # save to disk:
    with open("data/analysis-results.differential.example.json", 'w') as f:
        f.write(json.dumps(results))

    print("Results Summary:")
    for k,v in results.items():
        if k == 'results':
            print_results_summary(v, "\t")
        elif k != 'attachments':
            print("\t%s: %s" % (k, str(v)))

    print("Attachments:")
    results_diff = ""
    for idx, att in enumerate(results['attachments']):
        print("\t[%d] %s from %s for input '%s' : %s" % (idx, att['name'], att['output'], att['input'], att['mime-type'])) 
        if att['name'] == 'result-diff-csv':
            results_diff = att['data']

    print("Diff:")
    print(results_diff) # prints CSV to output
    df = pd.read_csv(io.StringIO(results_diff), sep="|")
    plot_differential(df)

"""
The result-diff-csv attachment has a header line which defines the columns, followed by one line for every row of data. Each row of data represents a comparison of the inputs. The groups column specifies whether the results are obtained from a single group (A or B), or from performing an operation on two groups (A*B). The inputs column specifies which items (input sample) within the group(s) are being compared; if empty, all items are compared. The operation column specifies which operations was performed. This is one of the following:

• I : Identity operation.

• A^B : Intersection, items in both B and A.

• A-B : Difference, items in A not in B. 

• B-A : Difference, items in B not in A. 

The remaining columns refer to diagnoses, and contain either +, -, or X, which generally means that the diagnosis is always positive (+), always negative (-), or is unstable (X), i.e. varying between positive and negative.

The first five rows look like this: 

A||I|X|-|-|X|-|X|+|+|-|X|-|-|-|+|+|+|+|X|-|-|X|X|X|+|X|-|-|-|-|X|-|-|-|-|-|-|-|X

Rows 1 and 2 determine the per-group stability of each diagnosis. In this example, the first diagnosis column (Atrial Fibrillation) is unstable amon the samples in group A, and also in group B. The second and third diagnosis column (Biventricular Hypertrophy and Bradycardia) are negative in all samples in groiup B, and also in group B. The sixth column (Disease Severity) is unstable (X) among samples in group A (meaning the disease severity diagnosis is positive in some but not all of those samples - note that the score itself is ignored in this comparison), but is negative (-) in all of the samples in group B. 

Rows 3, 4, and 5 contain the output of intersection and difference operations using rows 1 and 2 as input. In the intersection output (row 1), Atrial Fibrillation result is unstable (X), the Biventricular Hypertrophy and Bradycardia results are negative (-), and the Disease Severity result is unstable (X). Note that unstable, in this context, means “the diagnosis is unstable in at least one group”. The inersection results therefore show that the diagnosis columns which match between the two groups are 2, 3, 5, 7, 8, 9, 11, 12, 13, 14, 15, 19, 20, 24, 26, 27, 29, 31, 32, 33, 34, 35, 36, 37. The diagnosis columns which are stable in A but not in B are 16, 17, 28, and the diagnosis columns which are stable in B but not in A are 6, 23, 30, 38.

The remaining rows perform sample-to-sample comparisons, matching up each sample in group A with each sample in group B.
"""
